/*
 * Copyright (c) 2025, Salesforce, Inc.
 * SPDX-License-Identifier: Apache-2
 * For full license text, see the license.txt file in the repo root or http://www.apache.org/licenses/LICENSE-2.0
 */
import * as fs from 'node:fs/promises';
import {existsSync} from 'node:fs';
import path from 'node:path';
import {Flags, ux} from '@oclif/core';
import {BaseCommand} from '@salesforce/b2c-tooling-sdk/cli';
import {withDocs} from '../../../i18n/index.js';

/**
 * JSON output structure for setup ide prophet command.
 */
interface SetupIdeProphetResponse {
  overwritten: boolean;
  path: string;
}

/**
 * Build the dw.js script for Prophet integration.
 */
function buildDwJsScript(inspectArgs: string[]): string {
  return `/**
 * Auto-generated by "b2c setup ide prophet".
 * Purpose: Provide Prophet VS Code extension with dw.json-compatible configuration
 * by exporting the resolved B2C CLI config as module.exports.
 * support dwJson multi-config in prophet and other tools that support dw.js loading
 * when this is present prophet will ignore dw.json and instead load the configuration exported
 * This script shells out to: b2c setup inspect --json --unmask
 */
var childProcess = require('node:child_process');
var path = require('node:path');
var INSPECT_ARGS = ${JSON.stringify(inspectArgs)};
var dwJson = {};

function logProphetDw(message, error) {
  var suffix = error && error.message ? ': ' + String(error.message) : '';
  var line = '[b2c setup ide prophet] ' + message + suffix;

  try {
    console.error(line);
  } catch (logError) {}

  try {
    console.log(line);
  } catch (logError) {}
}

function loadDotEnv() {
  try {
    require('dotenv').config({override: true});
  } catch (error) {
    // optional dependency
  }
}

function getWorkspaceRoot() {
  if (process.env.SFCC_WORKING_DIRECTORY && process.env.SFCC_WORKING_DIRECTORY.trim()) {
    return process.env.SFCC_WORKING_DIRECTORY.trim();
  }

  if (process.env.SFCC_CONFIG && process.env.SFCC_CONFIG.trim()) {
    return path.dirname(process.env.SFCC_CONFIG.trim());
  }

  if (typeof __dirname === 'string' && __dirname) {
    return __dirname;
  }

  if (typeof module !== 'undefined' && module && module.filename) {
    return path.dirname(module.filename);
  }

  if (typeof workspace !== 'undefined' && workspace && Array.isArray(workspace.workspaceFolders)) {
    for (var i = 0; i < workspace.workspaceFolders.length; i += 1) {
      var folder = workspace.workspaceFolders[i];
      if (folder && folder.uri && typeof folder.uri.fsPath === 'string' && folder.uri.fsPath) {
        return folder.uri.fsPath;
      }
    }
  }

  return process.cwd();
}

function withWorkingDirectory(args, workingDirectory) {
  if (!workingDirectory || args.indexOf('--working-directory') !== -1) {
    return args.slice();
  }

  return args.concat(['--working-directory', workingDirectory]);
}

function pickInspectConfig(parsed) {
  if (!parsed || typeof parsed !== 'object') {
    return {};
  }

  var root = parsed.result && typeof parsed.result === 'object' ? parsed.result : parsed;

  if (root.config && typeof root.config === 'object') {
    return root.config;
  }

  if (root.result && root.result.config && typeof root.result.config === 'object') {
    return root.result.config;
  }

  return root;
}

function runSetupInspect(workingDirectory) {
  var inspectArgs = withWorkingDirectory(INSPECT_ARGS, workingDirectory);
  var candidates = [];

  if (process.env.B2C_CLI_BIN && process.env.B2C_CLI_BIN.trim()) {
    candidates.push({cmd: process.env.B2C_CLI_BIN.trim(), args: inspectArgs});
  }

  candidates.push({cmd: 'b2c', args: inspectArgs});
  candidates.push({cmd: 'npx', args: ['--yes', '@salesforce/b2c-cli'].concat(inspectArgs)});

  var lastError;

  for (var i = 0; i < candidates.length; i += 1) {
    var candidate = candidates[i];
    try {
      var execOptions = {
        encoding: 'utf8',
        stdio: ['ignore', 'pipe', 'pipe'],
      };
      if (workingDirectory) {
        execOptions.cwd = workingDirectory;
      }

      var stdout = childProcess.execFileSync(candidate.cmd, candidate.args, execOptions);
      return pickInspectConfig(JSON.parse(stdout));
    } catch (error) {
      logProphetDw('setup inspect candidate failed (' + candidate.cmd + ')', error);
      lastError = error;
    }
  }

  throw lastError || new Error('No setup inspect candidate succeeded');
}

function resolveDwJsonConfig(raw) {
  if (!raw || typeof raw !== 'object') {
    return {};
  }

  var instanceName = process.env.SFCC_INSTANCE;

  if (!instanceName || raw.name !== instanceName) {
    if (instanceName && Array.isArray(raw.configs)) {
      return raw.configs.find(function (item) {
        return item && item.name === instanceName;
      }) || raw;
    }

    if (Array.isArray(raw.configs) && raw.active !== true) {
      return raw.configs.find(function (item) {
        return item && item.active === true;
      }) || raw;
    }
  }

  return raw;
}

function loadDwJsonFallback(workingDirectory) {
  try {
    var dwJsonPath = process.env.SFCC_CONFIG ? process.env.SFCC_CONFIG : path.join(workingDirectory, 'dw.json');
    if (!path.isAbsolute(dwJsonPath)) {
      dwJsonPath = path.resolve(workingDirectory || process.cwd(), dwJsonPath);
    }

    return resolveDwJsonConfig(require(dwJsonPath));
  } catch (error) {
    logProphetDw('dw.json fallback failed', error);
    return {};
  }
}

function toProphetConfig(config) {
  if (!config || typeof config !== 'object') {
    return {};
  }

  var result = {};
  var codeVersion = config['code-version'] || config.codeVersion || config.version;

  if (config.hostname || config.server) {
    result.hostname = config.hostname || config.server;
  }
  if (config.username) {
    result.username = config.username;
  }
  if (config.password) {
    result.password = config.password;
  }
  if (codeVersion) {
    result['code-version'] = codeVersion;
    result.version = codeVersion;
  }
  if (config.cartridgesPath !== undefined) {
    result.cartridgesPath = config.cartridgesPath;
  }
  if (config.siteID !== undefined || config.siteId !== undefined) {
    result.siteID = config.siteID || config.siteId;
  }
  if (config.storefrontPassword !== undefined) {
    result.storefrontPassword = config.storefrontPassword;
  }
  if (config.cartridge !== undefined) {
    result.cartridge = config.cartridge;
  }

  return result;
}

function loadDwConfig() {
  loadDotEnv();
  var workingDirectory = getWorkspaceRoot();

  try {
    var inspectConfig = runSetupInspect(workingDirectory);
    var inspectMapped = toProphetConfig(inspectConfig);
    if (inspectMapped.hostname) {
      return inspectMapped;
    }

    logProphetDw('setup inspect returned no hostname; falling back to dw.json');
  } catch (error) {
    logProphetDw('setup inspect failed; falling back to dw.json', error);
  }

  try {
    var fallbackMapped = toProphetConfig(loadDwJsonFallback(workingDirectory));
    if (!fallbackMapped.hostname) {
      logProphetDw('dw.json fallback returned no hostname');
    }

    return fallbackMapped;
  } catch (error) {
    logProphetDw('dw.json mapping failed; returning empty config', error);
    return {};
  }
}

try {
  dwJson = loadDwConfig();
} catch (error) {
  logProphetDw('unexpected dw.js error; returning empty config', error);
  dwJson = {};
}

module.exports = dwJson;
`;
}

/**
 * Create dw.js integration script for Prophet VS Code extension.
 */
export default class SetupIdeProphet extends BaseCommand<typeof SetupIdeProphet> {
  static description = withDocs(
    'Generate a dw.js script that exposes B2C CLI config for Prophet VS Code',
    '/cli/setup.html#b2c-setup-ide-prophet',
  );

  static enableJsonFlag = true;

  static examples = [
    '<%= config.bin %> <%= command.id %>',
    '<%= config.bin %> <%= command.id %> --force',
    '<%= config.bin %> <%= command.id %> --output .vscode/dw.js',
    '<%= config.bin %> <%= command.id %> --instance staging',
  ];

  static flags = {
    ...BaseCommand.baseFlags,
    output: Flags.string({
      char: 'o',
      description: 'Path for generated script file',
      default: 'dw.js',
    }),
    force: Flags.boolean({
      char: 'f',
      description: 'Overwrite output file if it already exists',
      default: false,
    }),
  };

  async run(): Promise<SetupIdeProphetResponse> {
    const outputPath = path.resolve(this.flags.output);
    const alreadyExists = existsSync(outputPath);

    if (alreadyExists && !this.flags.force) {
      this.error(`File already exists at ${outputPath}. Use --force to overwrite.`);
    }

    const inspectArgs = this.buildInspectArgs();
    const script = buildDwJsScript(inspectArgs);

    await fs.mkdir(path.dirname(outputPath), {recursive: true});
    await fs.writeFile(outputPath, script, 'utf8');

    const result: SetupIdeProphetResponse = {
      path: outputPath,
      overwritten: alreadyExists,
    };

    if (!this.jsonEnabled()) {
      ux.stdout(`Created ${outputPath}`);
    }

    return result;
  }

  /**
   * Build setup inspect arguments for the generated script.
   * Includes setup context flags so runtime resolution matches command intent.
   */
  private buildInspectArgs(): string[] {
    const args = ['setup', 'inspect', '--json', '--unmask'];

    if (this.flags.instance) {
      args.push('--instance', this.flags.instance);
    }
    if (this.flags.config) {
      args.push('--config', this.flags.config);
    }
    if (this.flags['working-directory']) {
      args.push('--working-directory', this.flags['working-directory']);
    }

    return args;
  }
}
